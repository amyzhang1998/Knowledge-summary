# 名词

## `依赖注入（=== 控制反转）`

在 js 中依赖注入的概念不像 java 中被经常提到，主要原因是在 js 中很容易就实现了这种动态依赖。最简单的例子：bind 函数。js 可以通过 bind,apply,call 等函数可以很方便地控制函数的参数和 this 变量，所以简单地依赖注入在很多情况下已经被不知不觉地使用。在 AMD 的模块定义中，其方式也是一种依赖注入。

依赖注入（DI）和控制反转（IOC）基本是一个意思，因为说起来谁都离不开谁。

- `依赖注入`

因为大多数应用程序都是由两个或者更多的类通过彼此合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么将导致代码高度耦合并且难以维护和调试。所以才有了依赖注入的概念，依赖注入\*_解决了以下问题_：

1.  依赖之间的解耦单元测试，
2.  方便 Mock

- 控制反转

是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection, DI）, 还有一种叫"依赖查找"（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。

#### `总结`

- 依赖注入是控制反转的一种实现，实现代码解耦，便于单元测试。因为它并不需要了解自身所依赖的类，而只需要知道所依赖的类实现了自身所需要的方法就可以了。`你需要我，你却不认识我/`(ㄒ o ㄒ)/~~
- 控制反转提供一种调控系统，实现依赖解析的自动注入，一般配合容器提供依赖对象实例的引用。

## `硬件加速`

https://www.w3cplus.com/animation/animation-performance.html
parse html --> 计算样式 ---> layout --->paint ---图片解码 ---图片大小设置（css 改变宽度，需要 resize ）--合并图层不触发浏览器的 repaint.
影响 web 性能主要过程包括 layout（计算布局位置信息）/paint/composite

#### layout 任何有可能改变元素位置或大小的样式都会触发 layout;

float overflow padding position resize width text-align

#### 导致新图层的重建。

1.  进行 3D 或透视转换的 css 属性
2.  使用硬件加速视频解码的 video 元素。
3.  具有 3D(webGL)上下文或者硬件加速的 2D 上下文的 2D 上下文 canvas 元素。
4.  组合型插件（flash）;
5.  具有 css 透明度动画或者使用动画式 webkit 变换的元素。
6.  具有硬件加速的 css 滤镜的元素。

#### 重排 reflow 是指浏览器计算页面的全部或部分布局，重排一定引起重会。

#### DOM 元素的“Paint Only”属性（比如背景图片、文字颜色或阴影等），不会触发 layout 事件，只会绘制和渲染层合并

#### 非样式且非绘制的 css 属性，那么浏览器会跳过布局和绘制过程，直接合并。这种是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取用这种。

### 重排 和重回

    回流：当渲染树中的一部分或（全部） 因为元素的尺寸/布局/隐藏等改变而需要重新构建。导致回流的状况：

7.  调整窗口大小。
8.  改变字体
9.  增加或者移除样式表
10. 内容变化
11. 激活 css 伪类
    6。 操作 css 样式
12. 计算 offsetWidth 或 offsetHeight
13. 设置 style 属性的值。
14. css3 Animation 或 transition
    #### 重会：只是影响元素的外观，风格，不会影响布局的。重回不一定会引起回流，但是回流一定引起重回。

- 以下情况引起重排和重回

15. 页面首次加载，
16. dom 元素添加修改和删除（reflow+repaint）
17. 应用新的样式或修改任何影响元素外观的属性(repaint)
18. resize 浏览器窗口和滚动页面
19. 读取元素的某些属性（offsetLeft offetTop offsetHeight offsetWidth getComoutedStyle()）

#### 总结

消耗最低的是 transform 和 opacity;所以在制作动画时，建议使用 transform 的 translate 替代 margin 或 position 中的 top、right、bottom 和 left，同时使用 transform 中的 scaleX 或者 scaleY 来替代 width 和 height。页面滚动时，需要避免不必要的渲染及长时间渲染。其中不必要的渲染包括：

1.  position:fixed;。fixed 定位在滚动时会不停的进行渲染，特别是页面顶部有一个 fixed，页面底部有个类似返回顶部的 fixed，则在滚动时会对整个页面进行渲染，效率非常低。可以通过 transform: translateZ(0)或者 transform: translate3d(0,0,0)来解决
2.  overflow:scroll。前面说了，而在滚动也会触发 Repaint 和 Reflow。在调试过程中注意到一个有趣的现象，有时打开了页面并不会导致 crash，但快速滑动的时候却会。由于 crash 是页面本身内存占比过高，只要优化了页面的内存占用，滑动自然也不会是很大的问题。无论你在什么时候滑动页面，页面滚动都是一个不断重新组合重新绘制的过程。所以减少渲染区域在滚动里就显得非常重要。
3.  CSS 伪类触发。有些 CSS 伪类在页面滚动时会不小心触发到。比如:hover 效果有 box-shadow、border-radius 等比较耗时的 CSS 属性时，建议页面滚动时，先取消:hover 效果，滚动停止后再加上:hover 效果。这个可以通过在外层添加类名进行控制。但添加类名、删除类名也会改变元素时，浏览器就会要重新做一次计算和布局。所以千万要小心这种无意触发重新布局的操作，有的时候可能不是动画，但去付出的代价要比做一个动画更加昂贵。也就是说 classname 变化了，就一定会出现一次 rendering 计算，如果一定需要这么做，那可以使用 classlist 的方法。
4.  touch 事件的监听

## 负载均衡

## 生态- 内置 & 解耦

内置 MVVm 框架 ：Vue ,Ember。
与框架解耦的库：Mobx ,这些库需要一个中间层与框架衔接，比如 mobx-react、redux-box 解耦让框架更专注 View 层，实现了库与框架灵活搭配的能力。
解耦的数据流框架也诠释了更高抽象级别的 Mvvm 架构，即：View - 前端框架，Model - (mobx, dob)，ViewModel - (mobx-react, dob-react)。
同时也实现了数据与框架分离，便于测试与维护。比如下面的例子，左边是框架无关的纯数据/数据操作定义，右边是 View + ViewModel：

## 插件化思维

https://github.com/dt-fe/weekly/blob/master/53.%E7%B2%BE%E8%AF%BB%E3%80%8A%E6%8F%92%E4%BB%B6%E5%8C%96%E6%80%9D%E7%BB%B4%E3%80%8B.md
理想情况下，我们都希望一个库，或者一个框架具有足够的可拓展性。这个可拓展性体现在这三个方面：

- 让社区可以贡献代码，而且即使代码存在问题，也不会影响核心代码的稳定性。
- 支持二次开发，满足不同业务场景的特定需求。
- 让代码以功能为纬度聚合起来，而不是某个片面的逻辑结构，在代码数量庞大的场景尤为重要。

### 分类

插件化许多都是从设计模式演化而来的，大概可以参考的有：命令模式，工厂模式，抽象工厂模式等等，笔者根据个人经验，总结出三种插件化形式：

1.  约定/注入插件化。
    > 根据功能类型划分文件结构：

- 响应多个请求，逻辑单一，适用于用 class 的方式约定：
- 功能杂乱，没有清晰的功能入口，适用于用 class 的方式约定：

```
export default class User{
    async login(ctx:Context){
        ctx.json({ok:true})
    }
}
2..

export default (context:Context)=>{
    //context.sourceFiles.xx
}
```

2.  事件插件化。

    > 也可以解释为，事件机制就是在一些阶段放出钩子，允许用户代码拓展整体框架的生命周期。

3.  插槽插件化。
4.  最后还有一个不算插件化实现方式，但效果比较优雅，姑且称为分形插件化吧。下面一一解释。
