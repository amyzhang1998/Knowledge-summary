# Git

## 分布式版本控制系统

> 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任
> 何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复

## 忽略某些文件

所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配
。匹配模式最后跟反斜杠（/ ）说明要忽略的是目录。要忽略指定模式以外的文件或目录，
可以在模式前加上惊叹号（! ）取反。

```
# 此为注释 – 将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# ignore all .txt files in the doc/ directory
doc/**/*.txt
```

## 暂存已经修改的文件

git add

## 产看已暂存和未暂存的更新

> git diff : 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修
> 改之后还没有暂存起来的变化内容。 --cache/--staged : 若要看已经暂存起来的文件和
> 上次提交时的快照之间的差异

## 提交更新

> git commit -a : 跳过使用暂存区

## 移除文件

> git rm: 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是
> 从暂存区域移除），然后提交 ; -f : 如果删除之前修改过并且已经放到暂存区域的话，
> 则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改
> 的内容。

## 查看提交历史

git log -p -2: 我们常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的
两次更新：该选项除了显示基本信息之外，还在附带了每次 commit 的变化 -U1
--word-diff: 某些时候，单词层面的对比，比行层面的对比，更加容易观察 . 新增加的单
词被 {+ +} 括起来，被删除的单词被 [- -] 括起来 , 在进行单词层面的对比的时候，你
可能希望上下文（ context ）行数从默认的 3 行，减为 1 行，那么可以使用 -U1 选项。
上面

1. git log 还提供了许多摘要选项可以用，比如 --stat，仅显示简要的增改行数统计
   --stat: --pretty: 比如用 oneline 将每个提交放在一行显示，这在提交数很大时非常
   有用。另外还有 short，full 和 fuller 可以用， 2. 限制输出长度 -<n>:-2 表示仅
   显示最近的若干条提交 --since=2.weeks: 外还有按照时间作限制的选项，比如
   --since 和 --until; -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时
   间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指
   定作者相关的提交。 --committer 仅显示指定提交者相关的提交。

## 撤销操作

> 接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的
> ，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。有时候我们提交完了才
> 发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用
> --amend 选项重新提交： git commit --amend; 此命令将使用当前的暂存区域快照提交
> 。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说
> 明，但将要提交的文件快照和之前的一样。可以重新编辑 ci 的 message; 如果刚才提交
> 时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交： $ git commit
> -m 'initial commit' $ git add forgotten_file $ git commit --amend 上面的三条命
> 令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。

## 回退版本

1. Git 仓库有三个主要组成 —— 工作目录，缓存区和提交历史 git reset 提交层面 在私
   有分支上舍弃一些没有提交的更改 git reset 文件层面 将文件从缓存区中移除 git
   checkout 提交层面 切换分支或查看旧版本 git checkout 文件层面 舍弃工作目录中的
   更改 git revert 提交层面 在公共分支上回滚更改 git revert 文件层面 （然而并没
   有）
2. 提交层面的操作
   > 你传给 git reset 和 git checkout 的参数决定了它们的作用域。如果你没有包含文
   > 件路径，这些操作对所有提交生效。我们这一节要探讨的就是提交层面的操作。注意
   > ，git revert 没有文件层面的操作。 git checkout hotfix git reset HEAD~2 git
   > reset: 如果你的更改还没有共享给别人，git reset 是撤销这些更改的简单方法 ;
   > --soft – 缓存区和工作目录都不会被改变 --mixed – 默认选项。缓存区和你指定的
   > 提交同步，但工作目录不受影响 --hard – 缓存区和工作目录都同步到你指定的提交
   > 比如，git reset --mixed HEAD 将你当前的改动从缓存区中移除，但是这些改动还留
   > 在工作目录中。另一方面，如果你想完全舍弃你没有提交的改动，你可以使用 git
   > reset --hard HEAD。这是 git reset 最常用的两种用法。当你传入 HEAD 以外的其
   > 他提交的时候要格外小心，因为 reset 操作会重写当前分支的历史。正如 rebase 黄
   > 金法则所说的，在公共分支上这样做可能会引起严重的后果。
3. revert
   > Revert 撤销一个提交的同时会创建一个新的提交。这是一个安全的方法，因为它不会
   > 重写提交历史。比如，下面的命令会找出倒数第二个提交，然后创建一个新的提交来
   > 撤销这些更改，然后把这个提交加入项目中。git revert HEAD~2 相比 git reset，
   > 它不会改变现在的提交历史。因此，git revert 可以用在公共分支上，git reset 应
   > 该用在私有分支上。

## 取消已经暂存的文件

git reset HEAD index.rb: 从暂存区取消；

## 取消对文件的修改

git checkout 文件名 ;

## 从远程仓库抓取分支

git fetch: 需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前
工作分支，只有当你确实准备好了，才能手工合并。 git pull : 可以使用 git pull 命令
自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支

## 推送数据到远程

git push

## 查看远程仓库信息

git remote show origin

# Git 分支

> git 是如何存数据的？Git 保存的不是文件差异或者变化量，而只是一系列文件快照。

1. 新建 git branch dev
2. 切换 git checkout master
3. 新建并切换 git checkout -b dev
4. 删除分支 git branch -d dev
5. 合并切换到 master，将 dev 合并过来 git merge dev; 此时 dev 和 master 的
   fast-forward: 换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么
   Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要
   解决的分歧，所以这种合并过程可以称为快进（Fast forward ） . 还有更复杂的合并
   方式。
6. 分支的衍合 git rebase
7. 删除远程分支 git push [远程名] :[分支名] $ git push origin :serverfix
