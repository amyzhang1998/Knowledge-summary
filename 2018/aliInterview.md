## 遍历对象属性无序 的解决方法
每个浏览器在排序时都有自己的规则，顺序是不确定的。
1. 使用Map,然后使用 for...of...循环
 
 ```
 let myobject = new Map();
 myobject.set('zx',1)
 for(let [key,value] of myobject){
     console.log(key,key)
 }
 ```
 2. 构建一个单属性对象的数组。（一个保存key,一个保存value）
 ## 相等比较，object.is() 主要 针对 NaN,-0,+0的优势

 ## SSR 和 CSR的区别（服务端渲染和客户端渲染）
 服务端渲染：
 优势：1. 能够为客户提供更理想的性能
 2. 提供更为一致的 SEO 表现
 >区别：在使用SSR的情况下您的服务器对浏览器的响应结果属于已做好准备并可进行渲染的页面HTML，而CSR的浏览器响应结果则属于链接至您javascript的空文档。这意味着您的浏览器将立足服务器进行HTML渲染，而无需等待全部JavaSciprt代码的下载与执行。在这两种情况下，我们都需要下载React并利用同样的流程构建一个虚拟dom，而后附加各事件以实现页面交互——但在SSR方面，用户可在执行上述流程的同时查看到页面内容。而在CSR方面，大家则需要等待上述流程全部执行完成，而后方可进行查看。

 >注意事项：
 1. 尽管在SSR方面，页面会提前进行渲染以帮助客户更早查看页面内容，但在React真正执行完成之后，查看到的内容并无法进行交互。如果客户在此期间点击某按钮，该操作亦需要等待React执行完成后方可起效;
2. SSR TTFB（即第一字节时间）速度比CSR更慢，因为您的服务器需要耗费时间为页面创建HTML，而非直接发送相对较空的响应内容;
3. SSR的服务器数据吞吐量要远低于CSR数据通量。以React为例，这种数据吞吐量的差异将造成显著区别。ReactDOMServer.renderToString为一项同步CPU绑定调用，其中包含该事件循环，意味着服务器将无法在ReactDOMServer.renderToString完成之前处理其它请求。这里我们假定您的页面需要500毫秒进行SSR，则意味着您每秒至多只能执行2项请求。**请千万重视这一情况**

「后端渲染」指传统的 ASP、Java 或 PHP 的渲染机制；「前端渲染」指使用 JS 来渲染页面大部分内容，代表是现在流行的 SPA 单页面应用；「同构渲染」指前后端共用 JS，首次渲染时使用 Node.js 来直出 HTML。一般来说同构渲染是介于前后端中的共有部分。
##  前端埋点（数据采集）
>虽然我们之前已经详细描述过前端埋点的一些问题。例如，需要等待网络情况良好才能发送数据，需要积攒一定的量才发送数据，需要在本地暂存而本地暂存空间有限等一系列在数据传输性和数据可靠性上的一些问题。但是，前端埋点毕竟有一些后端采集数据所无法替代的地方，例如，分析前端界面设计是否合理，分析一些在与后端没有交互的前端行为等，还是必须采用前端埋点方案的。
### 前端埋点技术
https://sensorsdata.cn/blog/shu-ju-jie-ru-yu-mai-dian/?utm_source=baiduzhihu&utm_medium=free&utm_term=%E5%9F%8B%E7%82%B9&utm_content=2018%E5%B9%B45%E6%9C%88SDK%E6%B2%99%E9%BE%99&utm_campaign=%E5%86%85%E5%AE%B9%E9%97%AE%E7%AD%94
目前常见的前端埋点技术，有三类：
1. 在某个控件操作发生时通过预先写好的代码来发数据的代码埋点；
2. 通过可视化界面配置控件操作与事件发生关系的可视化埋点；
3. 先收集所有数据再在后端筛选需要分析的对象的“无埋点”。

### 问题