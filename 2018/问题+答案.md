## node 中 require 是用来加载 模块的。

问题：

#### require(filename) 是如何依据 fileName 找到对应的 module 呢？

> node 中解析 文件名 遵循一定的规则。

1.  为 node 的核心模块，stop
2.  以./或../开头，本地查找, stop
3.  沿着文件树，得到 node_module 的所有路径，知道/node_modules，在 node_module 中查找，stop
4.  path 为目录，则检查 package.json 文件是否存在 main 属性，否则默认为 index.js
5.  最后返回 new Error(‘Cannot find module”’ + request + ‘”’);

#### 为何模块中一定要通过 module.exports 暴露出接口？module.exports 与 require 存在什么关系？

那为什么使用 exports=bar 会报错，而使用 module.exports=bar 又是正确的呢？这是因为 exports 本身就只是 module.exports 的引用，而使用 require 加载模块的时候返回的是 module.exports，exports=bar 改变了 exports 的引用，所以最终返回的 module.exports 只是一个空对象，所以会报 TypeError 的错误。

> 所谓模块对象就是它们的作用域仅限于当前模块上面说了 require，exports 和 module 都是模块对象，但之所以可以在模块中不先声明就可以直接使用，是因为 node 在编译 js 模块的时候，将我们所写的代码进行了包装，将整个代码放进了一个函数中

## js 模块化 AMD CMD commonJs 规范以及 ES6 的模块化

CommonJS 的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。。AMD 规范则是非同步加载模块，允许指定回调函数。而 AMD 规范的实现，就是大名鼎鼎的 require.js 了

1.  require([module], callback)
2.  define(id, [depends], callback)

适合在浏览器环境中异步加载模块。可以并行加载多个模块。缺点： 提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。
但是 CMD 的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。优点：同样实现了浏览器端的模块化加载。可以按需加载，依赖就近。
缺点：依赖 SPM 打包，模块的加载逻辑偏重。

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。

#### es6 的 module 和 require 的区别？

ES6 Module 中导入模块的属性或者方法是强绑定的，包括基础类型；而 CommonJS 则是普通的值传递或者引用传递。

#### webpack 的 loader 实现原理？

#### css-loader 实现原理 过程？

## 设计模式

#### 观察者模式和订阅者-发布者的区别？
