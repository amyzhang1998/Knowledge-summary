# TCP/IP HTTP Socket

> 网络由下往上分为

物理层、数据链路层、**_网络层_**、**_传输层_**、会话层、表示层和**_应用层_**。　　通过初步的了解，我知道　　`IP协议对应于网络层`，`TCP协议对应于传输层，而HTTP协议对应于应用层`，表示层：加解密，解压缩跟压缩。信息的语义语法及其关联。会话层：不同机器上的用户之间建立会话的管理。ssl 握手传输层：三次握手三者从本质上来说没有可比性，

socket 则是对 TCP/IP 协议的封装和应用(程序员层面上)。

也可以说，TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输，

而 HTTP 是应用层协议，主要解决如何包装数据。

关于 TCP/IP 和 HTTP 协议的关系，网络有一段比较容易理解的介绍：

“我们在传输数据时，可以只使用(传输层)TCP/IP 协议，但是那样的话，如果没有应用层，便无法识别数据内容。

如果想要使传输的数据有意义，则必须使用到应用层协议。

应用层协议有很多，比如 HTTP、FTP、TELNET 等，也可以自己定义应用层协议。

WEB 使用 HTTP 协议作应用层协议，以封装 HTTP 文本信息，然后使用 TCP/IP 做传输层协议将它发到网络上。”

而我们平时说的最多的 socket 是什么呢，实际上 socket 是对 TCP/IP 协议的封装，Socket 本身并不是协议，而是一个调用接口(API)。

通过 Socket，我们才能使用 TCP/IP 协议。

实际上，Socket 跟 TCP/IP 协议没有必然的联系。

Socket 编程接口在设计的时候，就希望也能适应其他的网络协议。

所以说，Socket 的出现只是使得程序员更方便地使用 TCP/IP 协议栈而已，是对 TCP/IP 协议的抽象，

从而形成了我们知道的一些最基本的函数接口，比如 create、listen、connect、accept、send、read 和 write 等等。

网络有一段关于 socket 和 TCP/IP 协议关系的说法比较容易理解：

“TCP/IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。

这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样，

TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。”

关于 TCP/IP 协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道，

这个我打算会买一些经典的书籍(比如《TCP/IP 详解：卷一、卷二、卷三》)进行学习，今天就先总结一些基于基于 TCP/IP 协议的应用和编程接口的知识，也就是刚才说了很多的 HTTP 和 Socket。

CSDN 上有个比较形象的描述：HTTP 是轿车，提供了封装或者显示数据的具体形式;Socket 是发动机，提供了网络通信的能力。

实际上，传输层的 TCP 是基于网络层的 IP 协议的，而应用层的 HTTP 协议又是基于传输层的 TCP 协议的，而 Socket 本身不算是协议，就像上面所说，它只是提供了一个针对 TCP 或者 UDP 编程的接口。

下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。

一、什么是 TCP 连接的三次握手

第一次握手：客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认;

第二次握手：服务器收到 syn 包，必须确认客户的 SYN(ack=j+1)，同时自己也发送一个 SYN 包(syn=k)，即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态;

第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)

二、利用 Socket 建立网络连接的步骤

建立 Socket 连接至少需要一对套接字，其中一个运行于客户端，称为 ClientSocket ，另一个运行于服务器端，称为 ServerSocket 。

套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。

为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。

而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

三、HTTP 链接的特点

HTTP 协议即超文本传送协议(Hypertext Transfer Protocol )，是 Web 联网的基础，也是手机联网常用的协议之一，HTTP 协议是建立在 TCP 协议之上的一种应用。

HTTP 连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

四、TCP 和 UDP 的区别(考得最多。。快被考烂了我觉得- -\\)

1、TCP 是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但 TCP 的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;

而 UDP 不是面向连接的，UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说 UDP 是无连接的、不可靠的一种数据传输协议。

2、也正由于 1 所说的特点，使得 UDP 的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以 UDP 的实时性更好。

知道了 TCP 和 UDP 的区别，就不难理解为何采用 TCP 传输协议的 MSN 比采用 UDP 的 QQ 传输文件慢了，但并不能说 QQ 的通信是不安全的，

因为程序员可以手动对 UDP 的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，

> 即使是这样，UDP 因为在底层协议的封装上没有采用类似 TCP 的“三次握手”而实现>了 TCP 所无法达到的传输效率。

# http

#### tcp/ip 通信传输流

tcp/ip 协议族，最重要的一点就是分层，分为一下四层／

> 应用层--》传输层--》网络层--》链路层　发送方：　客户端　　 http -- tcp --ip -- 网络　接收方：　服务端　　网络 -- ip -- tcp --http
> 　发送端在层与层之间传送数据时，每经过一层，必定会被打上一个该层属于的首部信息，反之，接收端，在层与层之间传输时，每经过一层会把首部的信息去掉。

#### 1.4 与 http 关系密切的协议：IP TCP 和 DNS

##### 1.4.1 负责传输的 IP 协议

> ip 协议的作用把各种数据包传送给对方。而要保证数据发送到对方那里，则需要满足条件：（1）IP 地址：指明节点杯分配的地址。可变换。（2）mac 地址：指明网卡所属的固定地址。基本不会改变。
> ip 之间的通信依赖 mac 地址。使用 ARP（address resolution protocol）协议凭借 mac 地址进行通信。在到达通信目标的中转过程中，那些计算机和路由器等网络设备只能获取粗略的传输路线。

#####1.4.1 确保可靠性的 TCP 协议

> 提供可靠的字节流服务。tcp 为了更容易传送大数据，才将数据进行分割。而且 tcp 可以确认数据是否传送到对方：通过三次握手策略（three-way handshaking）。标有 SYN（synchronize）的数据包发送给你---》明白，收到数据包，并回发标有 SYN/ACK（acknowlwdgement）的数据包。---》明白。回发标有 ack 的数据包。

#### 1.5 负责域名解析的 DNS（应用层）

> 它提供域名到 IP 地址之间的解析服务。计算机即可以被赋予 IP 地址，也可以被赋予主机名和域名。

> http 的通信流程。（想浏览http://hackr.jp/xss/web页面）
> 客户端：1，告诉我 hack.jp 的 IP 地址
> 2.DNS 解析获取 IP
> 3，http 协议职责：生成针对目标 web 服务器的 http 请求报文
> 4，tcp 协议职责：将 http 请求报文分割成报文段，然后将报文段可靠传送
> 5，IP 协议职责：搜索对方的地址，一边中转，一边传送。（路由器）服务端：
> 6.tcp 协议职责：重组报文段。
> 7.http 协议职责：确定 IP 地址服务资源。最后，请求处理的结果也同样利用 tcp／ip 通信协议向用户回传。

#### 1.7 URL（统一资源定位符） 和 URI（统一资源标志符）

> URI 就是由某个协议方案表示的资源的定位标志符。URL 是 uri 的子集。

### 第二章，简单的 HTTp 协议。主要针对协议结构讲解

#### 2.1http 协议用于客户端和服务端之间的通信

#### 2.2 通过请求和响应的交换达成通信

> 请求报文是由请求方法。请求 uri，协议版本，可选的请求首部字段和内容实体构成。

#### 2.3 http 是不保存状态的协议

http 是无状态的协议，但为了实现期望的保持状态功能，于是就引入了 Cookie 技术。无状态好处：可以减少服务器的 cpu 及内存资源的消耗。

#### 2.5 告知服务器意图的 HTTP 方法

> Get：获取资源
>
> POST：传输实体主体
> PUT：传输文件
> HEAD:获得报文首部
> DELETE：删除文件
> OPTIONS：询问支持的方法
> TERACE：追踪路径
> CONNECT：要求用隧道协议连接代理

#### 持久连续节省通信量

> HTTP 协议的初始版本中，没进行一次 HTTP 通信就要断开一次 TCP 连接。但是如果请求图片资源很多的情况下，增加了通信量的开销，服务器压力会很大。（1）持久连接：特点是：只要任意一端没有明确提出断开连接，则保持 TCP 的连接状态。减轻服务端负载。加快页面加载速度（2）管线化：可以同时并行发送多个请求。而不需要一个接一个地等待响应。管线化比持久连接更快。

#### 使用 COOKIE 状态管理

> 请求头中写入 cookie.
> cookie 会根据从服务端发送的响应报文内的一个叫做 set-cookie 的首部字段信息。通知客户端保存 cookie，当下次客户端再往服务端发送请求时，客户端会在请求报文中加入 cookie。

### http 报文内的 http 信息

本章了解请求和响应如何运作的。

### http 状态码

> 正常：2XX，204:no content 206:partial content
> 异常：4XX（客户端错误），5XX（服务端错误）
> 400:bad request;401 unauthorized 403 forbidden 404 not found

### 第三章:http 报文内的 http 信息

1. 获取部分内容请求头：首部字段：Range
2. 内容协商返回合适内容：
   Accept Accept-Charset Accept-Encoding Accept-language Content-Language
3. 发送多种数据的多部分对象集合：首部字段：Content-Type:multipart/form-data;

### 第三章:返回结果的 http 状态码

    200 204 206
    301 302 303 304 307
    400 401 403 404
    500 503

### 第五章与 http 协作的 WEB 服务器

> 一台 web 服务器可搭建多个独立域名的 web 网站。也可作为通信路径上的中转服务器提升传输效率。

#### 5.1 用单台虚拟主机实现多个域名

> 在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 WEb 网站，因此在发送 http 请求时，必须在 HO 身体首部内完整指定主机名和域名的 URI。

#### 5.2 通信数据转发程序：代理／网管／隧道

> （1）代理：是一种有转发功能的应用程序；使用的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。。。代理按两种基类分类：一种是是否使用缓存，另一种修改报文。（2）网关：利用网关可以将 http 请求转为其他协议通信。利用网关能提高通信的安全性。因为可以在客户端和网关之间的通信线路上加密以确保连接的安全。（3）隧道：保证安全性。

#### 5.3 保存资源的缓存

> 缓存是指：在代理服务器或者客户端本地保存的资源副本。利用缓存可以减少对原服务器的访问，因此减少了通信流量和通信时间。

### 第六章 HTTP 首部

> 4 种 HTTP 首部字段类型通用首部字段，请求首部字段，相应首部字段，实体首部字段非首部字段：Cookie,setCookie Content-Disposition....
> Http 首部字段将定义成缓存代理和非缓存代理的行为，分为，端到端首部和逐跳首部：端到端首部：分在此类中的首部会转发给请求／响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定他必须被转发。逐跳首部：分在此类中的首部只对单次转发有效，会因通过缓存或代理而不再转发。

#### 通用首部字段

> 1,Catch-Control:能够操纵缓存的机制。缓存请求指令：no-cache,max-age,no-store...
> 缓存响应指令：no-cache,public,private
> no-cache 是不缓存过期资源，no-store 是不缓存
> 2:Connection:close,keep-alive
> 有两点控制不再转发给代理的首部字段管理持久连接
> 3:Date:
> 创建 http 报文的日期和时间
> 4:Transfer-Encoding:chunked;
> 传输报文主体时采用的编码方式。

#### 请求首部字段

> 1，Accept：text/html,application/xhtml+xmal,application/xml;q=0.9
> 通知服务器，用户代理可以处理的媒体类型以及媒体类型相对优先级。文本文件：text/html,text/plain...
> 图片文件：image/jpeg,image/png...
> 视频文件：video/mpeg...
> 应用程序使用的二进制文件：
> 2，Accept-Charset:iso-8859-5
> 3,Accept-Encoding:gzip....内容编码...
> 4,Accept-Language:zh-cn,en-us...
> 5,Host:告诉服务器，请求的资源所处的互联网主机名和端口号。
> 6，User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
> 会将创建请求的浏览器和用户代理的名称等信息给服务端

#### 响应首部字段

> 1,ETag:强 TAg,'usagi-1234';弱 tag:W/"uashf"
> '告知客户端实体标示，服务器会为每个分配 Etag
> 2:Server:Apache/2.2.1
> 告知客户端当前服务器上安装的 http 服务器应用的程序信息。
> 3，Vary：Accept-Language;
> vary 字段可以对缓存进行控制。仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。

#### 实体首部字段

> 1,Content-Encoding:gzip
> 告知客户端服务器对实体的主体选用的内容编码方式。
> 2,Contetn-Language:zh-ch
> 告知客户端所使用的自然语言集
> 3，Content-length:150000
> 4,Content-Type:
> 5,Content-Range:

#### 为 cookie 服务的首部字段

> 1,set-Cookie:
> Name=Vlaue：赋予 cookie 的名称和值（必选项）
> expires:Cookie 有效期
> path=PATH:将服务器上的文件目录作为 cookie 的适用对象
> domain=域名：作为 cookie 适用对象的域名
> secure:仅在 http 安全通信时才发送 cookie
> HttpOnly:使 cookie 不能被 js 脚本访问
> 2，Cookie：首部字段 cookie 会告知服务器，当客户端想获得 http 状态管理支持时，就会在请求中包含从服务端接收到的 COOKie。

## 7 章 https

http 不足：

1. 通信使用明文。内容可能被窃听。
2. 不验证通信方的身份，可能遭遇伪装
3. 无法证明报文的完整性，有可能已经被篡改

### 1. 通信使用明文。内容可能被窃听。

通信加密
http 与 ssl 组合使用就是 https
内容加密

### 2. 不验证通信方的身份，可能遭遇伪装

使用 ssl 查明证书

### 3. 无法证明报文的完整性，有可能已经被篡改

## http + 加密 +认证+完整性保护 =https

### ssl 协议

公开密钥加密方式很好的解决了共享密钥加密的困难。

1. https 使用混合加密机制
2. 证明公开密钥 正确性的证书

### 为什么不一直使用 https

3. 与纯文本通信相比，加密通信会消耗更多的 cpu 以及内存资源。
4. 证书开销

## 第九章

基于 http 功能追加协议

1. ajax
2. comet
3. websocket;支持服务器往客户端推送。
   upgrade 字段

## 第十一章 攻击技术针对 web

xss
sql 注入
http 首部注入
http 响应截断攻击开放重定向
