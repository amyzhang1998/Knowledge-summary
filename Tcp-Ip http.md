# TCP/IP  HTTP Socket

>网络由下往上分为

　　物理层、数据链路层、***网络层***、***传输层***、会话层、表示层和***应用层***。
　　通过初步的了解，我知道
　　`IP协议对应于网络层`，`TCP协议对应于传输层，而HTTP协议对应于应用层`，

　　三者从本质上来说没有可比性，

　　socket则是对TCP/IP协议的封装和应用(程序员层面上)。

　　也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，

　　而HTTP是应用层协议，主要解决如何包装数据。

　　关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：

　　“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。

　　如果想要使传输的数据有意义，则必须使用到应用层协议。

　　应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。

　　WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”

　　而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。

　　通过Socket，我们才能使用TCP/IP协议。

　　实际上，Socket跟TCP/IP协议没有必然的联系。

　　Socket编程接口在设计的时候，就希望也能适应其他的网络协议。

　　所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，

　　从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。

　　网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：

　　“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。

　　这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，

　　TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”

　　关于TCP/IP协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道，

　　这个我打算会买一些经典的书籍(比如《TCP/IP详解：卷一、卷二、卷三》)进行学习，今天就先总结一些基于基于TCP/IP协议的应用和编程接口的知识，也就是刚才说了很多的HTTP和Socket。

　　CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。

　　实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。

　　下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。

　　一、什么是TCP连接的三次握手

　　第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;

　　第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;

　　第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

　　握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

　　理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。

　　断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)

　　二、利用Socket建立网络连接的步骤

　　建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

　　套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。

　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。

　　而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

　　三、HTTP链接的特点

　　HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

　　HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

　　四、TCP和UDP的区别(考得最多。。快被考烂了我觉得- -\\)

　　1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;

　　而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。

　　2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。

　　知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，

　　因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，
>即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现>了TCP所无法达到的传输效率。


#http

####tcp/ip通信传输流
tcp/ip协议族，最重要的一点就是分层，分为一下四层／
>　　应用层--》传输层--》网络层--》链路层
　发送方：　客户端
　　http -- tcp --ip -- 网络
　接收方：　服务端
　　网络 -- ip -- tcp --http
>　发送端在层与层之间传送数据时，每经过一层，必定会被打上一个该层属于的首部信息，反之，接收端，在层与层之间传输时，每经过一层会把首部的信息去掉。

####1.4与http关系密切的协议：IP TCP 和DNS
#####1.4.1负责传输的IP协议
>ip协议的作用把各种数据包传送给对方。而要保证数据发送到对方那里，则需要满足条件：（1）IP地址：指明节点杯分配的地址。可变换。
（2）mac地址：指明网卡所属的固定地址。基本不会改变。
ip之间的通信依赖mac地址。使用ARP（address resolution protocol）协议凭借mac地址进行通信。在到达通信目标的中转过程中，那些计算机和路由器等网络设备只能获取粗略的传输路线。

#####1.4.1确保可靠性的TCP协议
>提供可靠的字节流服务。tcp 为了更容易传送大数据，才将数据进行分割。而且tcp 可以确认数据是否传送到对方：通过三次握手策略（three-way handshaking）。
>标有SYN（synchronize）的数据包发送给你---》明白，收到数据包，并回发标有SYN/ACK（acknowlwdgement）的数据包。---》明白。回发标有ack的数据包。

####1.5负责域名解析的DNS（应用层）
>它提供域名到IP地址之间的解析服务。计算机即可以被赋予IP地址，也可以被赋予主机名和域名。

>http的通信流程。
（想浏览http://hackr.jp/xss/web页面）
客户端：1，告诉我hack.jp的IP地址
2.DNS解析获取IP
3，http 协议职责：生成针对目标web服务器的http请求报文
4，tcp协议职责：将http请求报文分割成报文段，然后将报文段可靠传送
5，IP协议职责：搜索对方的地址，一边中转，一边传送。（路由器）
服务端：
6.tcp协议职责：重组报文段。
7.http协议职责：确定IP地址服务资源。
最后，请求处理的结果也同样利用tcp／ip通信协议向用户回传。

####1.7 URL（统一资源定位符） 和URI（统一资源标志符）
>URI就是由某个协议方案表示的资源的定位标志符。URL是uri的子集。

###第二章，简单的HTTp协议。主要针对协议结构讲解
####2.1http协议用于客户端和服务端之间的通信
####2.2通过请求和响应的交换达成通信
>请求报文是由请求方法。请求uri，协议版本，可选的请求首部字段和内容实体构成。

####2.3 http是不保存状态的协议
http是无状态的协议，但为了实现期望的保持状态功能，于是就引入了Cookie技术。
无状态好处：可以减少服务器的cpu及内存资源的消耗。
####2.5告知服务器意图的HTTP方法
>Get：获取资源
>
>POST：传输实体主体
>PUT：传输文件
>HEAD:获得报文首部
>DELETE：删除文件
>OPTIONS：询问支持的方法
>TERACE：追踪路径
>CONNECT：要求用隧道协议连接代理

####持久连续节省通信量
>HTTP协议的初始版本中，没进行一次HTTP通信就要断开一次TCP连接。但是如果请求图片资源很多的情况下，增加了通信量的开销，服务器压力会很大。
>（1）持久连接：特点是：只要任意一端没有明确提出断开连接，则保持TCP的连接状态。减轻服务端负载。加快页面加载速度
>（2）管线化：可以同时并行发送多个请求。而不需要一个接一个地等待响应。
>管线化比持久连接更快。

####使用COOKIE状态管理
>请求头中写入cookie.
>cookie会根据从服务端发送的响应报文内的一个叫做set-cookie的首部字段信息。通知客户端保存cookie，当下次客户端再往服务端发送请求时，客户端会在请求报文中加入cookie。

###http报文内的http信息
本章了解请求和响应如何运作的。
###http状态码
>正常：2XX，204:no content 206:partial content
异常：4XX（客户端错误），5XX（服务端错误）
400:bad request;401 unauthorized 403 forbidden 404 not found

###第五章与http协作的WEB服务器
>一台web 服务器可搭建多个独立域名的web网站。也可作为通信路径上的中转服务器提升传输效率。

####5.1用单台虚拟主机实现多个域名
>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的WEb网站，因此在发送http请求时，必须在HO身体首部内完整指定主机名和域名的URI。

####5.2通信数据转发程序：代理／网管／隧道
>（1）代理：是一种有转发功能的应用程序；
>使用的理由：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。。。
>代理按两种基类分类：一种是是否使用缓存，另一种修改报文。
>（2）网关：利用网关可以将http请求转为其他协议通信。
>利用网关能提高通信的安全性。因为可以在客户端和网关之间的通信线路上加密以确保连接的安全。
>（3）隧道：保证安全性。

####5.3保存资源的缓存
>缓存是指：在代理服务器或者客户端本地保存的资源副本。利用缓存可以减少对原服务器的访问，因此减少了通信流量和通信时间。

###第六章HTTP首部
>4种HTTP首部字段类型
>通用首部字段，请求首部字段，相应首部字段，实体首部字段
>非首部字段：Cookie,setCookie Content-Disposition....
>Http首部字段将定义成缓存代理和非缓存代理的行为，分为，端到端首部和逐跳首部：
>端到端首部：分在此类中的首部会转发给请求／响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定他必须被转发。
>逐跳首部：分在此类中的首部只对单次转发有效，会因通过缓存或代理而不再转发。

####通用首部字段
>1,Catch-Control:能够操纵缓存的机制。
>缓存请求指令：no-cache,max-age,no-store...
>缓存响应指令：no-cache,public,private
>no-cache是不缓存过期资源，no-store是不缓存
>2:Connection:close,keep-alive
>有两点
>控制不再转发给代理的首部字段
>管理持久连接
>3:Date:
>创建http报文的日期和时间
>4:Transfer-Encoding:chunked;
>传输报文主体时采用的编码方式。

####请求首部字段
>1，Accept：text/html,application/xhtml+xmal,application/xml;q=0.9
>通知服务器，用户代理可以处理的媒体类型以及媒体类型相对优先级。
>文本文件：text/html,text/plain...
>图片文件：image/jpeg,image/png...
>视频文件：video/mpeg...
>应用程序使用的二进制文件：
>2，Accept-Charset:iso-8859-5
>3,Accept-Encoding:gzip....内容编码...
>4,Accept-Language:zh-cn,en-us...
>5,Host:告诉服务器，请求的资源所处的互联网主机名和端口号。
>6，User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36
>会将创建请求的浏览器和用户代理的名称等信息给服务端

####响应首部字段
>1,ETag:强TAg,'usagi-1234';弱tag:W/"uashf"
>'告知客户端实体标示，服务器会为每个分配Etag
>2:Server:Apache/2.2.1
>告知客户端当前服务器上安装的http服务器应用的程序信息。
>3，Vary：Accept-Language;
>vary字段可以对缓存进行控制。仅对请求中含有相同Vary指定首部字段的请求返回缓存。

####实体首部字段
>1,Content-Encoding:gzip
>告知客户端服务器对实体的主体选用的内容编码方式。
>2,Contetn-Language:zh-ch
>告知客户端所使用的自然语言集
>3，Content-length:150000
>4,Content-Type:
>5,Content-Range:

####为cookie服务的首部字段
>1,set-Cookie:
>Name=Vlaue：赋予cookie的名称和值（必选项）
>expires:Cookie有效期
>path=PATH:将服务器上的文件目录作为cookie的适用对象
>domain=域名：作为cookie适用对象的域名
>secure:仅在http安全通信时才发送cookie
>HttpOnly:使cookie不能被js脚本访问
>2，Cookie：首部字段cookie会告知服务器，当客户端想获得http状态管理支持时，就会在请求中包含从服务端接收到的COOKie。






　　

