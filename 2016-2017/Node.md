# Node
## mySql
## sql语句
创建： CREATE DATABASE test
删除：DROP DATABASE test2;
### 默认端口
1. < 1024
2. > 1024
mySql :
## 数据库技术基础
### 修改和删除表
1. 修改表
语句格式：
ALTER TABLE <表名>[ADD<新列名><数据类型>[完整性约束条件]]
                    [DROP[完整性约束名]]
                    [MODIFY<列名><数据类型>
2. 删除表
DROP TABLE<表名>
## SQL数据查询 （SELECT，INSERT，DELETE,UPDATE）
SELECT[ALL|DISTINCT]<目标列表表达式>[,<目标列表表达式>]...
        FROM<表名或视图名>[,<表名或视图名>]...
        [WHERE<条件表达式>]
        [GROUP BY<列名1][HAVING<条件表达式>]]
        [ORDER BY<列名2][ASC|DESC]...]
>select其输出可以是列名，表达式，集函数（AVG/COUNT/MAX/MIN/SUM）,DISTINCT选项可以保证查询的结果集中不存在重复元祖。

# 深入浅出Node
>第二章：从代码组织结构看node，3，从运行结构，4，从编程结构，5从Node中内存结构的揭示，6，从node中的数据在I/O流中结构或者状态。7，从网络服务角度，8node在http上的展现，9node的单机集群结构，10.从单元测试和性能测试。

## Node 特点（高性能i/o）
>1. 异步I/O
2.  事件与回调函数
3. 单线程
>>单线程的弱点，
1.无法利用多核CPU。2. 错误会引起整个应用退出，应用的健壮性值得考验。
 3. 大量计算占用Cpu导致无法继续调用异步I/O>> NODE采用子进程来解决单线程中大计算量问题
 ## Node的适用场景(并行I/O)
 1. I/O密集型。从单线程角度，能有效组织起更多的硬件资源。
 ## 第二章： 模块规范 commonJS
 > node 借鉴CommonJS的规范实现了一套模块系统。
 1. 模块引用
 var math = require('math')
 2. 模块定义
 使用exports关键字。
 exports.add = function(){...}//math.js
 var math = require('math')
 exports.increment = function(){ return math.add(...)}
 3. 模块标识。是传给require的参数，必须符合小驼峰命名的字符串，或者是绝对路径或是相对路径。
 ### node的模块实现：了解实现exports require module的过程
 引入模块的3个步骤
 1. 路径分析
 2. 文件定位
 3. 编译执行
 模块分为两类：1是node提供的模块，核心模块。2.用户编写的模块称文件模块。
 核心模块在node源码编译过程中，已经编译进了二进制文件，被放置在内存中。所以加载速度快。第二三步骤都可以省略
 文件模块是运行时动态加载，需要完整的三个步骤。
 #### 优先从缓存加载
 > node 对引入的模块都会进行缓存，缓存的是编译执行后的对象而浏览器缓存的是文件。核心模块优先于文件模块的缓存检查。
 #### 路径分析和文件定位
 1. 模块标识符分析
 >  分为以下几类（优先级一次降低，最高为缓存模块）
 1）：核心模块 如：http. fs
 2）：以.或..开始的相对路径模块
 3）：以/开始的绝对路径模块
 4）：非路径形式的文件模块，如自定义的connect模块
 2. 文件定位
 文件定位中需要注意，主要包括文件扩展名的分析，目录和包的处理。
 1）： 文件扩展名分析
 > commonjs 规范允许不包含文件扩展名，这种情况下，node会按照.js .json .node的次序补充扩展名依次尝试。在尝试的过程中
 ，需要调用fs模块的同步阻塞判断文件是否存在。因为node是单线程，所以会引起性能问题。诀窍是，如果是node和.json后缀，
 建议带上后缀名。另一个是同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷。

 2) 目录分析和包。
 > require没有得到文件，而是得到一个目录，此时node会将目录当做包来处理。
 包的出现是在模块的基础上进一步组织js代码。包规范包括：包结构和包描述两个部分。
 ## 包描述文件（package.json）和npm
 ## 前后端共用模块
 前后端模块的侧重点不一样，所以也衍生出不同的规范。
 前端有AMD CMD规范
 浏览器端js:从一个服务器端分发到多个客户端执行。瓶颈：是带宽。通过网络加载代码
 服务端js:相同的代码需要多次执行。瓶颈：cpu和内存等资源。通过磁盘加载。
 ## 第三章 异步I/O
 ### 为什么要异步I/O
 >在 跨网络的结构下，并发已经是现代编程的标准配备。
 1. 用户体验响应
 因为浏览器中js在单线程中执行，而且与UI渲染共用一个线程。通过异步可以消除ui阻塞现象。而且前端获取服务端资源也取决于后端的
 响应速度，随着应用的复杂性，资源会分布到多台服务器上，分布式将会是常态。异步比同步获取的时间会更短。后端能够快速响应资源能让前端的体验更好。
 2. 资源分配
 > 计算机在发展过程中将组件进行了抽象，分为I/O设备和计算设备。
 单线程同步编程会因阻塞i/O导致硬件资源得不到更优的使用，多线程编程模型也因为编程中死锁，状态同步等问题。。。
 node：利用单线程，远离多线程死锁，利用异步I/O，让单线程远离阻塞，以更好使用CPU。
 为了弥补单线程无法利用多核cpu，node提供了子进程。
 ### 异步I/O实现现状
 1. 异步I/O与非阻塞I/O
 从计算机内核i/o而言，异步/同步，阻塞/非阻塞是两回事。
 操作系统内核对于i/o只有两种方式，阻塞和非阻塞。
 阻塞i/o造成cpu等待，浪费等待时间。非阻塞i/o调用后，数据立即返回，缺点是，立即返回的并不是业务层需要的数据，为了获取完整数据，
 需要轮询调用。
 ### node的异步i/o
 1. 事件循环---node自身的执行模型
 事件循环有i/o观察者。进程启动时，会创建一个tick循环，每个tick循环就是查看是否有待处理的事件。如果有，就取出事件及其相关回调。
事件循环是典型的生产者/消费者模型，异步I/O、网络请求等则是事件的生产者，这些事件传递到观察者那，事件循环从观察者那里取出并处理。
2. 请求对象 
node中的异步i/o调用而言，回调函数不由开发者调用。从发出调用后，到回调函数被执行，中间发生了什么？从js发起调用到内核执行完i/o操作的过渡过程有一个中间产物，请求对象。所有状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理。
3. 执行回调
组装好请求对象，送入i/o线程池等待执行，实际完成的是异步i/o的第一部分。回调通知是第二部分。
 
 事件循环，观察者，请求对象和i、o事件池共同构成了node 异步i/o模型的基本要素。
 ### 非i/o的异步api
 setTimeout() setInterval() setInediate()  process.nextTick()



