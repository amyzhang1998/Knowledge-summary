# Jquery
## 工具方法
>实际上jQuery是一个函数，为什么要这样设计呢，是因为：
>1. 函数也是对象，于是在jQuery这个命名空间上可以绑定工具方法
>2. 函数可以有原型prototype，每当通过dom = $(“#id”)取得的所谓jQuery对象，本质就是dom = new jQuery(‘#id’);

>简单来说，就是把jQuery看成是一个类，在原型上绑定方法就相当于成员方法，在jQuery上绑定工具方法，相当于类的静态方法.

### 常用的工具方法
1. $.trim() 去除字符串两端的空格。（内部调用7次）
2. $.each() 遍历数组或对象，这个方法在jQuery内部中被使用很多次，有几个不错的用法，之后剖析再举例吧。（内部调用59次）

3. $.inArray() 返回一个值在数组中的索引位置。如果该值不在数组中，则返回-1。（内部调用9次）

4. $.grep() 返回数组中符合某种标准的元素。（内部调用6次）

5. $.merge() 合并两个数组。（内部调用11次）

6. $.map() 将一个数组中的元素转换到另一个数组中。（内部调用12次）

7. $.makeArray() 将对象转化为数组。（内部调用6次）

8. $.globalEval() 在全局作用域下执行一段js脚本。（内部调用2次）

9. $.proxy() 接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文(context)语境。（内部调用0次）

10. $.nodeName() 返回DOM节点的节点名字，或者判断DOM节点名是否为某某名字。（内部调用51次）

11. $.extend() 将多个对象，合并到第一个对象。（内部调用42次）

>以下均是对类型的判断，本文只是针对$.type做一下讨论，isXXX的方法基本都是调用$.type来实现，不对它们做细节探讨。

12. $.type() 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）。这个方法的实现就是用$.each辅助的。（内部调用65次）

13. $.isArray() 判断某个参数是否为数组。（内部调用12次）

14. $.isEmptyObject() 判断某个对象是否为空（不含有任何属性）。（内部调用4次）

15. $.isFunction() 判断某个参数是否为函数。（内部调用32次）

16. $.isPlainObject() 判断某个参数是否为用”{}”或”new Object”建立的对象。（内部调用4次）

17. $.isWindow() 判断是否为window对象。（内部调用6次）

>以下三个函数比较简单，没必要在文章剖析。

18. $.noop() 一个空函数，个人觉得是用来作为一个默认的回调函数，无需每次去定义一个空的function消耗资源。（内部调用2次）

19. $.now() 获取当前时间戳，代码很简单：return (new Date()).getTime();。（内部调用4次）

20. $.error() 报错，对外抛出一个异常，代码很简单：throw new Error(msg);。（内部调用2次）

>以下三个是jQuery主要用来在ajax处理返回数据时使用，其中parseJSON这个接口在实际工程中被用得最多，经常用来把一段文本解析成json格式

21. $.parseHTML() 解析HTML，之后再单独一节写。（内部调用2次）

22. $.parseJSON() 解析JSON，之后再单独一节写。（内部调用2次）

23. $.parseXML() 解析XML，之后再单独一节写。（内部调用1次）

> 其中我认为是内部辅助函数如下：

24. $.access() 这个函数我更认为是jQuery内部的辅助函数，没必要暴漏出来，在内部用于去一些对象的属性值等，在之后剖析到DOM操作等再细细探讨一下。（内部调用9次）

25. $.camelCase() 转化成骆驼峰命名。（内部调用12次）

### 分析：

```
define( [
	"./arr"
], function( arr ) {
	"use strict";

	return arr.push;
} );

define( [
	"./class2type"
], function( class2type ) {
	"use strict";

	return class2type.toString;
} );

```
问题：jquery选择把array，string等这些数据类型的基本方法先存储起来调用的原因？
1. 效率问题
>调用实例arr的方法concat时，首先需要辨别当前实例arr的类型是Array，在内存空间中寻找Array的concat内存入口，把当前对象arr的指针和其他参数压入栈，跳转到concat地址开始执行。
当保存了concat方法的入口core_concat时，完全就可以省去前面两个步骤，从而提升一些性能。

2. var obj = {};
> 此时调用obj.concat是非法的，但是如果jQuery采用上边方式二或者三的话，能够解决这个问题。
也即是让类数组也能用到数组的方法（这就是call跟apply带来的另一种用法），尤其在jQuery里边引用一些DOM对象时，也能完美的用这个方法去解决，妙！

